# Bearer Authorization

## Review, Research, and Discussion

1- **Write the following steps in the correct order:**

- Receive access token
- Redirect to a third party authentication endpoint
- Register your application to get a client_id and client_secret
- Make a request to a third-party API endpoint
- Ask the client if they want to sign in via a third party
- Receive authorization code
- Make a request to the access token endpoint

  1- Register your application to get a client_id and client_secret.

  2- Ask the client if they want to sign in via a third party.

  3- Redirect to a third party authentication endpoint.

  4- Make a request to a third-party API endpoint

  5- Receive authorization code.

  6- Make a request to the access token endpoint.

  7- Receive access token

2- **What can you do with an authorization code?**

*For Authorization Code grant type, the first step is to issue an auth code to the client. The client will then get back with the auth code and client credentials to request for a token.*

3- What can you do with an access token?

*It will include that token as a credential when making API requests. To do so, it should transmit the access token to the API as a Bearer credential in an HTTP Authorization header.*

4- What’s a benefit of using OAuth instead of your own basic authentication?

  *Sharing user data between applications without sharing the user’s credentials. For ex: logging into spotify thru facebook or logging into codepen account using your github login credentials. “known as secure, third-party, user-agent, delegated authorization”. VOCAB Client ID username or some information unique to the user.*

## Document the following Vocabulary Terms

- **Client ID** is the unique identifier provided to an app upon registration.
- **Client Secret** is a unique and confidential value held between the authorization server and authorized clients. It restricts the issuing of access tokens to trusted requestors.
- **Authentication Endpoint** An API endpoint used for requesting access to resources.
- **Access Token Endpoint** An API endpoint for requesting a token.
- **API Endpoint** is the touch point between applications that points to the necessary resources; in other words where your request goes.
- **Authorization Code** A random string generated by the authorization server and returned to the application as part of the authorization response. The authorization code is relatively short-lived and is exchanged for an Access Token at the token endpoint when using the Authorization Code Flow.
- **Access Token** A credential that is used by an application to access an API. It informs the API that the bearer has been authorized

## Preparation Materials

### **JWTs Explained**

**What is JSON Web Token?**

***JSON Web Token (JWT)*** is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA or ECDSA.

### **Intro to JWT**

**Why should we use JSON Web Tokens?**

Let's talk about the benefits of JSON Web Tokens (JWT) when compared to Simple Web Tokens (SWT) and Security Assertion Markup Language Tokens (SAML).

As JSON is less verbose than XML, when it is encoded its size is also smaller, making JWT more compact than SAML. This makes JWT a good choice to be passed in HTML and HTTP environments.

Security-wise, SWT can only be symmetrically signed by a shared secret using the HMAC algorithm. However, JWT and SAML tokens can use a public/private key pair in the form of a X.509 certificate for signing. Signing XML with XML Digital Signature without introducing obscure security holes is very difficult when compared to the simplicity of signing JSON.

### **Are JWTs Secure?**

JWTs can be either signed, encrypted or both. If a token is signed, but not encrypted, everyone can read its contents, but when you don't know the private key, you can't change it. Otherwise, the receiver will notice that the signature won't match anymore.

Answer to your comment: I'm not sure if I understand your comment the right way. Just to be sure: do you know and understand digital signatures? I'll just briefly explain one variant (HMAC, which is symmetrical, but there are many others).

Let's assume Alice wants to send a JWT to Bob. They both know some shared secret. Mallory doesn't know that secret, but wants to interfere and change the JWT. To prevent that, Alice calculates Hash(payload + secret) and appends this as signature.